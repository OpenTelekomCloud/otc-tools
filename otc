#!/bin/bash
# vi:set ts=3 sw=3:
# == Module: Open Telekom Cloud Cli Interface 0.6.x
#
# Manage OTC via Command Line
#
# === Parameters
#
# === Variables
#
# === Examples
#
# Examples
# See help ...
#
# === Authors
#
# Zsolt Nagy <Z.Nagy@t-systems.com>
# Kurt Garloff <t-systems@garloff.de>
# Christian Kortwich <christian.kortwich@t-systems.com>
#
# === Copyright
#
# Copyright 2016 T-Systems International GmbH
# License: CC-BY-SA 3.0
#

VERSION=0.6.19

# Get Config ####################################################################
warn_too_open()
{
	PERM=$(stat -Lc "%a" "$1")
	if test "${PERM:2:1}" != "0"; then
		echo "Warning: $1 permissions too open ($PERM)"
	fi
}

may_read_env_files()
{
	for file in "$@"; do
		if test -r "$file"; then
			echo "Note: Reading environment from $file ..."
			source "$file"
			warn_too_open "$file"
			if test -n "$OS_PASSWORD" -a -n "$OS_USERNAME"; then break; fi
		fi
	done
}

otc_dir="$(dirname "$0")"
# Parse otc-tools specific config file (deprecated)
if test -r ~/.otc_env.sh; then
	source ~/.otc_env.sh
	warn_too_open ~/.otc_env.sh
#else
#	echo "Note: No ~/.otc_env.sh found, no defaults for ECS creation"
fi
# Parse standard OpenStack environment setting files if needed
if test -n "$OS_PASSWORD" -o -z "$OS_USERNAME"; then
	may_read_env_files ~/.ostackrc.$OTC_TENANT ~/.ostackrc ~/.novarc ~/novarc 
fi
# Defaults
if test -z "$OS_USER_DOMAIN_NAME"; then
	export OS_USER_DOMAIN_NAME="${OS_USERNAME##* }"
fi
if test -z "$OS_PROJECT_NAME"; then
	export OS_PROJECT_NAME="eu-de"
fi
# S3 environment
if test -z "$S3_ACCESS_KEY_ID" -a -r ~/.s3rc.$OTC_TENANT; then
	echo "Note: Reading S3 environment from ~/.s3rc.$OTC_TENANT ..."
	source ~/.s3rc.$OTC_TENANT
	warn_too_open ~/.s3rc.$OTC_TENANT
fi
if test -z "$S3_ACCESS_KEY_ID" -a -r ~/.s3rc; then
	echo "Note: Reading S3 environment from ~/.s3rc ..."
	source ~/.s3rc
	warn_too_open ~/.s3rc
fi
# Alternatively parse CSV as returned by OTC
if test -r ~/credentials-$OTC_TENANT.csv; then
	CRED=credentials-$OTC_TENANT.csv
else
	CRED=credentials.csv
fi
if test -z "$S3_ACCESS_KEY_ID" -a -r ~/$CRED; then
	echo -n "Note: Parsing S3 $CRED ... "
	LN=$(tail -n1 ~/$CRED | sed 's/"//g')
	UNM=${LN%%,*}
	LN=${LN#*,}
	if test "$UNM" = "$OS_USERNAME"; then
		echo "succeeded"
		export S3_ACCESS_KEY_ID="${LN%,*}"
		export S3_SECRET_ACCESS_KEY="${LN#*,}"
	else
		echo "user mismatch \"$UNM\" != \"$OS_USERNAME\""
	fi
	warn_too_open ~/$CRED
fi

if test -z "$OS_USERNAME" -o -z "$OS_PASSWORD"; then
	echo "ERROR: Need to set OS_USERNAME, OS_PASSWORD, and OS_PROJECT_NAME environment"
	echo " Optionally: OS_CACERT, HTTPS_PROXY, S3_ACCESS_KEY_ID, and S3_SECRET_ACCESS_KEY"
	exit 1
fi

# ENVIROMENT SETTINGS ####################################################################

# Defaults
if test -z "$BANDWIDTH"; then BANDWIDTH=25; fi
if test -z "$VOLUMETYPE"; then VOLUMETYPE="SATA"; fi

test -n "$S3_HOSTNAME" || export S3_HOSTNAME=obs.otc.t-systems.com

if test -n "$OS_AUTH_URL"; then
	export IAM_AUTH_URL="$OS_AUTH_URL/auth/tokens"
else
	export IAM_AUTH_URL="https://iam.eu-de.otc.t-systems.com/v3/auth/tokens"
fi

# Generic wrapper to facilitate debugging
docurl()
{
	if test -n "$DEBUG"; then
		echo DEBUG: curl "$@" | sed -e 's/X-Auth-Token: MII[^ ]*/X-Auth-Token: MIIsecretsecret/g' -e 's/"password": "[^"]*"/"password": "SECRET"/g' 1>&2
		ANS=`curl "$@"`
		echo "DEBUG: $ANS" | sed 's/X-Subject-Token: MII.*$/X-Subject-Token: MIIsecretsecret/' 1>&2
		echo "$ANS"
	else
		curl "$@"
	fi
}

curlpost()
{
	docurl $INS -i -sS -H "Content-Type: application/json" -d "$1" "$2"
}

curlpostauth()
{
	TKN="$1"; shift
	docurl $INS -sS -X POST \
		-H "Content-Type: application/json" \
		-H "Accept: application/json" \
		-H "X-Auth-Token: $TKN" \
		-H "X-Language: en-us" \
		-d "$1" "$2"
}

curlputauth()
{
	TKN="$1"; shift
	docurl $INS -sS -X PUT -H "Content-Type: application/json" -H "Accept: application/json" \
		-H "X-Auth-Token: $TKN" -d "$1" "$2"
}

curlgetauth()
{
	TKN="$1"; shift
	docurl $INS -sS -X GET -H "Content-Type: application/json" -H "Accept: application/json" -H "X-Auth-Token: $TKN" -H "X-Language: en-us" "$1"
}

curldeleteauth()
{
	TKN="$1"; shift
	docurl $INS -sS -X DELETE -H "Accept: application/json" -H "X-Auth-Token: $TKN" "$1"
}

curldeleteauthwithjsonparameter()
{
	# $1: TOKEN
	# $2: PARAMETER
	# $3: URI 
	TKN="$1"; shift
	docurl $INS -sS -X DELETE \
	-H "Content-Type: application/json" \
	-H "X-Language: en-us" \
	-H "X-Auth-Token: $TKN" -d "$1" "$2" | jq .
}

unset SUBNETAZ

##########################################################################################

#FUNCTIONS ###############################################################################

# TODO: Token caching ...

getIamToken() {
	if test -n "$OS_PROJECT_ID"; then
	IAM_REQ='{
			"auth": {
			"identity": {
				"methods": [ "password" ],
				"password": {
					"user": {
						"name": "'"$OS_USERNAME"'",
						"password": "'"$OS_PASSWORD"'",
						"domain": { "name": "'"${OS_USER_DOMAIN_NAME}"'" }
					}
				}
			},
			"scope": {
				"project": { "id": "'"$OS_PROJECT_ID"'" }
			}
		}
	}
	'
	else
	IAM_REQ='
	{
		"auth": {
			"identity": {
			"methods": [ "password" ],
				"password": {
				"user": {
					"name": "'"$OS_USERNAME"'",
					"password": "'"$OS_PASSWORD"'",
					"domain": { "name": "'"${OS_USER_DOMAIN_NAME}"'" }
				}
			}
		},
			"scope": {
				"project": { "name": "'"$OS_PROJECT_NAME"'" }
			}
		}
	}
	'
	fi
	export IAM_REQ
	#if test -n "$DEBUG"; then
	#	echo "curl $INS -d $IAM_REQ $IAM_AUTH_URL" | sed 's/"password": "[^"]*"/"password": "SECRET"/g'
	#fi
	IAMRESP=`curlpost "$IAM_REQ" "$IAM_AUTH_URL"`

	# DEBUG only: echo "$IAMRESP" | tail -n1 | jq -C .

	#if test -n "$DEBUG"; then
	#	echo "$IAMRESP" | sed 's/X-Subject-Token: MII.*$/X-Subject-Token: MIIsecretsecret/'
	#fi
	TOKEN=`echo "$IAMRESP" | grep "X-Subject-Token:" | cut -d' ' -f 2`
	#echo ${TOKEN} | sed -e 's/[0-9]/./g' -e 's/[a-z]/x/g' -e 's/[A-Z]/X/g'
	if test -z "$OS_PROJECT_ID"; then
		OS_PROJECT_ID=`echo "$IAMRESP" | tail -n1 | jq -r '.token.project.id'`
	fi
	if test -z "$TOKEN" -o -z "$OS_PROJECT_ID"; then
		echo "ERROR: Failed to authenticate and get token from $IAM_AUTH_URL for user $OS_USERNAME"
		exit 2
	fi
	if test -z "$OS_USER_DOMAIN_ID"; then
		OS_USER_DOMAIN_ID=`echo "$IAMRESP" | getUserDomainIdFromIamResponse `
	fi
	if test -z "$OS_USER_DOMAIN_ID"; then
		echo "ERROR: Failed to determine user domain id from $IAM_AUTH_URL for user $OS_USERNAME"
		exit 2
	fi

	# SET ENDPOINTS
	# TODO: Parse catalog instead
	export BASEURL=${IAM_AUTH_URL%%/v3*}

	AUTH_URL_ECS="${BASEURL/iam/ecs}/v2/$OS_PROJECT_ID/servers"
	export AUTH_URL_ECS_JOB="${BASEURL/iam/ecs}/v1/$OS_PROJECT_ID/jobs"
	export AUTH_URL_ECS_DETAIL="${BASEURL/iam/ecs}/v2/$OS_PROJECT_ID/servers/detail"

	AUTH_URL_ECS_CLOUD="${BASEURL/iam/ecs}/v1/$OS_PROJECT_ID/cloudservers"
	AUTH_URL_ECS_CLOUD_ACTION="${BASEURL/iam/ecs}/v1/$OS_PROJECT_ID/cloudservers/action"
	AUTH_URL_ECS_CLOUD_DELETE="${BASEURL/iam/ecs}/v1/$OS_PROJECT_ID/cloudservers/delete"

	AUTH_URL_VPCS="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/vpcs"
	AUTH_URL_PUBLICIPS="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/publicips"
	AUTH_URL_SEC_GROUPS="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/security-groups"
	AUTH_URL_SEC_GROUP_RULES="${BASEURL/iam/vpc}/v2/$OS_PROJECT_ID/security-group-rules"
	AUTH_URL_SUBNETS="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/subnets"

	AUTH_URL_IMAGES="${BASEURL/iam/ims}/v2/images"

	AUTH_URL_FLAVORS="${BASEURL/iam/ecs}/v1/$OS_PROJECT_ID/cloudservers/flavors"
	AUTH_URL_KEYNAMES="${BASEURL/iam/ecs}/v2/$OS_PROJECT_ID/os-keypairs"

	AUTH_URL_VOLUMES="${BASEURL/iam/evs}/v2/$OS_PROJECT_ID/cloudvolumes"
	AUTH_URL_VOLUMES_DETAILS="${BASEURL/iam/evs}/v2/$OS_PROJECT_ID/cloudvolumes/detail"

	AUTH_URL_ELB="${BASEURL/iam/elb}/v1.0/$OS_PROJECT_ID/elbaas"
	AUTH_URL_ELB_LB="$AUTH_URL_ELB/loadbalancers"

	AUTH_URL_RDS="${BASEURL/iam/rds}/rds"
	AUTH_URL_RDS="${AUTH_URL_RDS/:443\///}" # remove :443 port when present
	AUTH_URL_RDS_DOMAIN="${AUTH_URL_RDS}/v1/$OS_USER_DOMAIN_ID"
	AUTH_URL_RDS_PROJECT="${AUTH_URL_RDS}/v1/$OS_PROJECT_ID"
}

getECSVM() {
	curlgetauth $TOKEN "$AUTH_URL_ECS/$VM" | jq -r '.[]'
	curlgetauth $TOKEN "$AUTH_URL_ECS/$VM/os-interface" | jq -r '.[]'
}

getECSList() {
	curlgetauth $TOKEN "$AUTH_URL_ECS" | jq -r  '.servers[] | {id: .id, name: .name} | .id +"   " +.name  '
}

getECSDetail() {
	curlgetauth $TOKEN "$AUTH_URL_ECS_DETAIL" | jq '.servers[] | {VM:  .name, ID: .id, Detail: .}'
}

getVPCList() {
	curlgetauth $TOKEN "$AUTH_URL_VPCS?limit=42" | jq -r '.vpcs[] | {id: .id, name: .name, status: .status, cidr: .cidr} | .id +"   " +.name    +"   " +.status   +"   " +.cidr  '
#| python -m json.tool
}

getPUBLICIPSList() {
	curlgetauth $TOKEN "$AUTH_URL_PUBLICIPS?limit=42" | jq '.publicips[]  | {id: .id, pubip: .public_ip_address, privip: .private_ip_address, status: .status, bid: .bandwidth_id, bandwidth: .bandwidth_size|tostring , bandwidth_share_type: .bandwidth_share_type} | .id +"   " +.pubip +"   " +.privip +"   " +.status +"   " +.bid +"   " +.bandwidth +"   " +.bandwidth_share_type ' | tr -d '"'
}

getSECGROUPListDetail() {
	curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS?limit=500" | jq '.[]'
#| python -m json.tool
}

getSECGROUPList() {
	curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS?limit=160" | jq '.security_groups[] | {id: .id, name: .name, vpc: .vpc_id} | .id +"   " +.vpc +"   " +.name' | tr -d '"'
#| python -m json.tool
}

getSECGROUPRULESListOld() {
	curlgetauth $TOKEN "$AUTH_URL_SEC_GROUP_RULES" | jq '.[]'
#| python -m json.tool
}

getSECGROUPRULESList() {
	curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS?limit=500" | jq '.security_groups[] | select(.id == "'$1'")'
#| python -m json.tool
}

getEVSList() {
	curlgetauth $TOKEN "$AUTH_URL_VOLUMES" | jq '.volumes[] | {id: .id, name: .name} | .id +"   " +.name ' | tr -d '"'
}

getEVSDetail() {
	curlgetauth $TOKEN "$AUTH_URL_VOLUMES_DETAILS?limit=160" | jq '.volumes[] | select(.id == "'$1'")'
}

getSUBNETList() {
	curlgetauth $TOKEN "$AUTH_URL_SUBNETS?limit=160" | jq '.[]'
#| python -m json.tool
}

getRDSInstanceList() {
	curlgetauth $TOKEN "${AUTH_URL_RDS_DOMAIN}/instances" | jq -r  '.instances[] | {id: .id, name: .name, type: .type} | .id + "   " + .name + " " + .type'
}

getRDSAllInstanceDetailsImpl() {
	curlgetauth $TOKEN "${AUTH_URL_RDS_DOMAIN}/instances" | jq -r .instances[]
}

getRDSInstanceDetailsImpl() {
	local instanceid
	for instanceid in $*
	do
		local URI="${AUTH_URL_RDS_DOMAIN}/instances/${instanceid}"
		#echo "URI: $URI"
		curlgetauth $TOKEN "$URI" | jq -r '.instance'
	done
}

getRDSInstanceDetails() {
	[ $# -eq 0 ] && getRDSAllInstanceDetailsImpl
	[ $# -ne 0 ] && getRDSInstanceDetailsImpl "$@"
}

getRDSDatastoreDetails() {
	local datastore_name
	for datastore_name in $*
	do
		local URI="${AUTH_URL_RDS_DOMAIN}/datastores/${datastore_name}/versions"
		#echo "URI: $URI"
		curlgetauth $TOKEN "$URI" | jq -r '.dataStores[]'
	done
}

getRDSAPIVersionList() {
	curlgetauth $TOKEN "${AUTH_URL_RDS}/" | \
		jq -r  '.versions[] | {id: .id, status: .status, updated: .updated} | .id+" "+.status+" "+.updated'
}

getRDSAPIDetails() {
	local api_id
	for api_id in $*
	do
		curlgetauth $TOKEN "${AUTH_URL_RDS}/${api_id}" | jq .versions[]
	done
}

getRDSFlavorList() {
	local dbid=$1;   shift
	local region=$1; shift
	[ -z "$region" ] && region=$OS_PROJECT_NAME # default to env
	local URI="${AUTH_URL_RDS_DOMAIN}/flavors?dbid=${dbid}&region=${region}"
	#echo "URI: $URI"
	curlgetauth $TOKEN "$URI" | jq -r .
	#\ jq -r  '.instances[] | {id: .id, name: .name, type: .type} | .id + "   " + .name + " " + .type'
}

getRDSFlavorDetails() {
	for flavorid in $*
	do
		local URI="${AUTH_URL_RDS_DOMAIN}/flavors/${flavorid}"
		#echo "URI: $URI"
		curlgetauth $TOKEN "$URI" | jq -r '.flavor'
	done
}

createRDSInstanceImpl() {
	# Parameter $* as descibed in
	# API Reference Issue 01 2016-06-30,
	# 4.7 Creating an Instance
	local URI="${AUTH_URL_RDS_DOMAIN}/instances"
	#echo "Parameter: $*"
	#echo "URI: $URI"
	curlpostauth $TOKEN "$*" "$URI" | jq '.'
}

createRDSInstance() {
	local rds_parameters="",zwerg;
	if [ $# -eq 0 ]; then
		# no parameter file given, read from stdin
		while read zwerg
		do
			rds_parameters.="$zwerg"
		done
	else
		rds_parameters=`cat $1`
	fi
	createRDSInstanceImpl "$rds_parameters"
}

deleteRDSInstanceImpl() {
	local instanceid=$1
	local numberOfManualBackupsToKeep=$2
	local URI="${AUTH_URL_RDS_DOMAIN}/instances/${instanceid}"
	#local URI="${AUTH_URL_RDS_PROJECT}/instances/${instanceid}"
	echo "Try deleting instance $instanceid"
	#echo "URI: $URI"
	#echo "TOKEN: $TOKEN"
	curldeleteauthwithjsonparameter \
		$TOKEN \
		"{ \"keepLastManualBackup\":\"${numberOfManualBackupsToKeep}\" }" \
		"$URI" 
}

deleteRDSInstance() {
	[ $# -eq 2 ] && deleteRDSInstanceImpl "$@"
	[ $# -eq 0 ] && echo "ERROR: Please specify RDS instance id to delete and number of backups to keep" 
}

getid() {
	head -n1 | cut -d':' -f2 | tr -d '" ,'
}

# Params: ARRNM Value [attr [id]]
find_id()
{
	ANM=${3:-name}
	IDN=${4:-id}
	jq '.'$1'[] | select(.'$ANM' == "'$2'") | .'$IDN | tr -d '", '
}

# convert functions
convertSUBNETNameToId() {
	#curlgetauth $TOKEN "$AUTH_URL_SUBNETS?limit=160"
	#SUBNETID=`curlgetauth $TOKEN "$AUTH_URL_SUBNETS" | jq '.subnets[] | select(.name == "'$SUBNETNAME'") | .id' | tr -d '" ,'`
	SUBNETS=`curlgetauth $TOKEN "$AUTH_URL_SUBNETS?limit=160"`
   SUBNETID=`echo "$SUBNETS" | find_id subnets "$SUBNETNAME"`
	SUBNETAZ=`echo "$SUBNETS" | find_id subnets "$SUBNETNAME" name availability_zone`
	export SUBNETID SUBNETAZ
}

convertVPCNameToId() {
	#curlgetauth $TOKEN "$AUTH_URL_VPCS?limit=42"
	#VPCID=`curlgetauth $TOKEN "$AUTH_URL_VPCS?limit=42" | jq '.vpcs[] | select(.name == "'$VPCNAME'") | .id' | tr -d '" ,'`
	VPCID=`curlgetauth $TOKEN "$AUTH_URL_VPCS?limit=42" | find_id vpcs "$VPCNAME"`
	#echo $VPCID
	export VPCID
}

convertSECUGROUPNameToId() {
	#curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS?limit=160" > ~/tmp/sg
	#SECUGROUP=`curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS" | jq '.security_groups[] | select(.name == "'$SECUGROUPNAME'") | .id' | tr -d '" ,'`
	#SECUGROUP=`curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS" | find_id security_groups "$SECUGROUPNAME"`
	SECUGROUP=`curlgetauth $TOKEN "$AUTH_URL_SEC_GROUPS?limit=160" | jq '.security_groups[] | select(.name == "'"$SECUGROUPNAME"'") | select(.vpc_id == "'"$VPCID"'") | .id' | tr -d '" ,'`
	if test `echo "$SECUGROUP" | wc -w` != 1; then
		echo "WARNING: Non-unique Security Group mapping: $SECUGROUPNAME -> $SECUGROUP"
		SECUGROUP=`echo "$SECUGROUP" | head -n 1`
	fi
	export SECUGROUP
}

convertIMAGENameToId() {
	#curlgetauth $TOKEN "$AUTH_URL_IMAGES?limit=160" > ~/tmp/img
	#IMAGE_ID=`curlgetauth $TOKEN "$AUTH_URL_IMAGES" | jq '.images[] | select(.name == "'$IMAGENAME'") | .id' | tr -d '" ,'`
	IMAGE_ID=`curlgetauth $TOKEN "$AUTH_URL_IMAGES?limit=160" | find_id images "$IMAGENAME"`
	export IMAGE_ID
}

getIMAGEList() {
	curlgetauth $TOKEN "$AUTH_URL_IMAGES?limit=160"| jq '.images[] | .id +"   "+.name ' | tr -d '"'
#| python -m json.tool
}

getIMAGEDetail() {
	curlgetauth $TOKEN "$AUTH_URL_IMAGES?limit=160"| jq '.images[] | select(.id == "'$1'")'
#| python -m json.tool
}

getFLAVORListOld() {
	curlgetauth $TOKEN "$AUTH_URL_FLAVORS?limit=80"| jq '.[]'
#| python -m json.tool
}

getFLAVORList() {
	curlgetauth $TOKEN "$AUTH_URL_FLAVORS?limit=80"| jq '.flavors[] | "\(.id)   \(.name)  \(.vcpus)  \(.ram)  \(.os_extra_specs)"' | tr -d '"'
#| python -m json.tool
}

getKEYPAIRList() {
	curlgetauth $TOKEN "$AUTH_URL_KEYNAMES?limit=160" | jq '.[]'
#| python -m json.tool
}

getKEYPAIR() {
	curlgetauth $TOKEN "$AUTH_URL_KEYNAMES/$1" | jq '.[]'
#| python -m json.tool
}

createKEYPAIR() {
	if test -n "$2"; then PKEY="\"public_key\": \"$2\", "; fi
	curlpostauth $TOKEN "{ \"keypair\": { $PKEY \"name\": \"$1\" } }" "$AUTH_URL_KEYNAMES" | jq '.'
}

deleteKEYPAIR() {
	curldeleteauth $TOKEN "$AUTH_URL_KEYNAMES/$1"
}


createELB() {
	if test -n "$3"; then BANDWIDTH=$3; fi
	if test -n "$2"; then NAME="$2"; fi
	if test -z "$NAME"; then
		if test -z "$INSTANCE_NAME"; then NAME="ELB-$BANDWIDTH"; else NAME="$INSTANCE_NAME"; fi
	fi
	ELBTYPE='"type": "External"'
	if test -n "$SUBNETID"; then
		ELBTYPE='"type": "Internal", "vip_subnet_id": "'$SUBNETID'"'
	elif test -n "$SUBNETNAME"; then
		convertSUBNETNameToId
		ELBTYPE='"type": "Internal", "vip_subnet_id": "'$SUBNETID'"'
	fi
	if test -n "$1"; then VPCID=$1; fi
	if [ -z "$VPCID" -a -n "$VPCNAME" ]; then convertVPCNameToId; fi
	if test -z "$VPCID"; then echo "ERROR: Need to specify VPC"; exit 1; fi
	ELBJOBID=`curlpostauth $TOKEN "{ \"name\": \"$NAME\", \"description\": \"LB\", \"vpc_id\": \"$VPCID\", \"bandwidth\": $BANDWIDTH, $ELBTYPE, \"admin_state_up\": 1 }" "$AUTH_URL_ELB_LB" | jq '.job_id' | cut -d':' -f 2 | tr -d '" '`
	export ELBJOBID

}

getELBList() {
	curlgetauth $TOKEN "$AUTH_URL_ELB_LB?limit=100" | jq '.[]'
}

getELBDetail() {
	curlgetauth $TOKEN "$AUTH_URL_ELB_LB/$1" | jq '.'
}

deleteELB() {
	ELBJOBID=`curldeleteauth $TOKEN "$AUTH_URL_ELB_LB/$1" | jq '.job_id' | cut -d':' -f 2 | tr -d '" '`
	export ELBJOBID
}

getListenerList() {
	curlgetauth $TOKEN "$AUTH_URL_ELB/listeners?loadbalancer_id=$1" | jq '.[]'
}

deleteListener() {
	curldeleteauth $TOKEN "$AUTH_URL_ELB/listeners/$1"
}

# echo "otc elb addlistener <eid> <name> <proto> <port> [<alg> [<beproto> [<beport>]]]"
createListener() {
	ALG="$5"
	BEPROTO="$6"
	BEPORT=$7
	if test -z "$ALG"; then ALG="source"; fi
	if test -z "$BEPROTO"; then BEPROTO="$3"; fi
	if test -z "$BEPORT"; then BEPORT=$4; fi
	if test "$3" = "HTTP" -o "$3" = "HTTPS"; then STICKY="\"session_sticky\": \"true\", "; fi
	curlpostauth $TOKEN "{ \"name\": \"$3\", \"loadbalancer_id\": \"$1\", \"protocol\": \"$3\", \"port\": $4, \"backend_protocol\": \"$BEPROTO\", \"backend_port\": $BEPORT, $STICKY\"lb_algorithm\": \"$ALG\" }" "$AUTH_URL_ELB/listeners" | jq '.[]'

}

#echo "otc elb addcheck <lid> <proto> <port> <int> <to> <hthres> <uthres> [<uri>]"
createCheck() {
	HTHR="$6"
	UTHR="$7"
	if test -z "$HTHR"; then HTHR=3; fi
	if test -z "$UTHR"; then UTHR=$HTHR; fi
	URI="$8"
	if test "$2" = "HTTP" -o "$2" = "HTTPS" && test -z "$URI"; then URI="/"; fi
	if test -n "$URI"; then URI="\"healthcheck_uri\": \"$URI\", "; fi

	curlpostauth "$TOKEN" "{ \"listener_id\": \"$1\", \"healthcheck_protocol\": \"$2\", $URI\"healthcheck_connect_port\": $3, \"healthcheck_interval\": $4, \"healthcheck_timeout\": $5, \"healthy_threshold\": $HTHR, \"unhealthy_threshold\": $UTHR }" "$AUTH_URL_ELB/healthcheck" | jq '.[]'
}

deleteCheck() {
	curldeleteauth $TOKEN "$AUTH_URL_ELB/healthcheck/$1"
}

getCheck() {
	curlgetauth $TOKEN "$AUTH_URL_ELB/healthcheck/$1" | jq '.'
}

#   echo "otc elb listmember <lid>"
getMemberList() {
	curlgetauth $TOKEN "$AUTH_URL_ELB/listeners/$1/members" | jq '.[]'
}

#   echo "otc elb addmember <lid> <vmid> <vmip>"
createMember() {
	curlpostauth $TOKEN "[ { \"server_id\": \"$2\", \"address\": \"$3\" } ]" "$AUTH_URL_ELB/listeners/$1/members"
	#TODO JOB_ID ...
}

#   echo "otc elb delmember <lid> <mid> <addr>"
deleteMember() {
	curlpostauth $TOKEN "{ \"removeMember\": [ { \"id\": \"$2\", \"address\": \"$3\" } ] }" "$AUTH_URL_ELB/listeners/$1/members/action"
	#TODO JOB_ID ...
}

printHelp() {
   echo "otc-tools version $VERSION: OTC API tool"
   echo "Usage:"
   echo "--- Elastic Cloud Server (VM management) ---"
   echo "otc ecs list               # list ecs instances"
   echo "otc ecs list-detail        # list ecs instances in detail"
   echo "otc ecs vm <id>            # show instance <id>"
   echo "otc ecs create -n <name>   # create ecs instance <name>"
   echo
   echo "otc ecs create             # create vm example"
   echo "    --count 1              # one instance (default)"
   echo "    --public true          # with public ip"
   echo "    --file1 /tmp/a=/otc/a  # attach local file /tmp/a to /otc/a in VM"
   echo "    --file2 ...            # Up to 5 files can be injected this way"
   echo
   echo "otc ecs create             # create vm (addtl. options)"
   echo "    --instance-type       <FLAVOR>"
   echo "    --instance-name       <NAME>"
   echo "    --image-name          <IMAGE>"
   echo "    --subnet-name         <SUBNET>"
   echo "    --vpc-name            <VPC>"
   echo "    --security-group-name <SGNAME>"
   echo "    --security-group-ids  <SGID>,<SGID>,<SGID>"
   echo "    --admin-pass          <PASSWD>"
   echo "    --key-name            <SSHKEYNAME>"
   echo "    --public              <true/false>"
   echo "    --bandwidth           <BW>		# defaults to 25"
   echo "    --bandwidth-name      <BW-NAME>	# defaults to bandwidth-BW"
   echo "    --disksize            <DISKGB>"
   echo "    --disktype            SATA|SAS|SSD	# SATA is default"
   echo "    --az                  <AZ>		# determined from subnet by default"
   echo "    --[no]wait"
   echo
   echo "otc ecs reboot-instances <id>   # reboot ecs instance <id>"
   echo "                                # optionally --soft/--hard"
   echo "otc ecs stop-instances <id>     # stop ecs instance <id>, dito"
   echo "otc ecs start-instances <id>    # start ecs instance <id>"
   echo "otc ecs delete <id> <id> ...    # delete VM along with EIPs"
   echo "otc ecs job <id>                # show status of job <id>"
   #echo "otc task show <id>              # show status of job <id>"
   #echo "otc task delete <id>            # cancel job <id>"
   echo
   echo "--- SSH Keys ---"
   echo "otc keypair list                # list ssh key pairs"
   echo "otc keypair show <KPNAME>       # show ssh key pair"
   echo "otc keypair create <NAME> [<PUBKEY>]      # create ssh key pair"
   echo "otc keypair delete <KPNAME>     # delete ssh key pair"
   #TODO keypair creation, deletion, ...
   echo
   echo "--- Elastic Volumes ---"
   echo "otc evs list                    # list all volumes"
   echo "otc evs show <id>               # show details of volume <id>"
   #TODO volume attach, detach, create, change, delete ...
   echo
   echo "--- Virtual Private Network ---"
   echo "otc vpc list                    # list all vpc"
   echo
   echo "otc vpc create                  # create vpc"
   echo "    --vpc-name <vpcname>"
   echo "    --cidr     <cidr>"
   echo
   echo "otc subnet list                 # list all subnet"
   echo
   echo "otc subnet create               # create a subnet"
   echo "    --subnet-name       <subnetname>"
   echo "    --cidr              <cidr>"
   echo "    --gateway-ip        <gateway>"
   echo "    --primary-dns       <primary-dns>"
   echo "    --secondary-dns     <sec-dns>"
   echo "    --availability-zone <avalibility zone>"
   echo "    --vpc-name          <vpcname>"
   echo
   echo "otc publicip list               # list all publicips"
   echo
   echo "otc publicip create             # create a publicip"
   echo "    --bandwidth-name    <bandwidthame>"
   echo "    --bandwidth         <bandwidth>"
   echo
   echo "otc publicip delete <id>        # delete a publicip (EIP)"
   echo "otc publicip bind <publicip-id> <port-id> # bind a publicip to a port"
   echo "otc publicip unbind <publicip-id>         # unbind a publicip"
   echo
   echo "otc security-group list                   # list all sec. group"
   echo "otc security-group-rules list <group-id>  # list rules of sec. group <group-id>"
   echo
   echo "otc security-group create                 # create security group"
   echo "    -g <groupname>"
   echo "    --vpc-name <vpc name>"
   echo
   echo "otc security-group-rules create           # create sec. group rule"
   echo "    --security-group-name <secgroupname>"
   echo "    --direction           <direction>"
   echo "    --protocol            <protocol: tcp, udp, icmp>"
   echo "    --ethertype           <ethtype: IPv4,IPv6>"
   echo "    --portmin             <port range lower end>"
   echo "    --portmax             <port range upper end>"
   echo
   echo "--- Image Service ---"
   echo "otc images list         # list all images"
   echo "otc images show <id>    # show image details"
   echo "otc images upload <id> bucket:objname     # specify image source (s3)"
   echo
   echo "--- Elastic Load Balancer ---"
   echo "otc elb list            # list all load balancer"
   echo "otc elb show <id>       # show elb details"
   echo "otc elb create [<vpcid> [<name> [<bandwidth>]]]   # create new elb"
   echo "     --vpc-name <vpcname>"
   echo "     --bandwidth <bandwidth>    # in Mbps"
   echo "     --subnet-name/id <subnet>  # creates internal ELB listening on subnet"
   echo "otc elb delete <eid>            # Delete ELB with <eid>"

   echo "otc elb listlistener <eid>      # list listeners of load balancer <eid>"
   echo "otc elb addlistener <eid> <name> <proto> <port> [<alg> [<beproto> [<beport>]]]"
   #not implemented: modifylistener
   echo "otc elb dellistener <lid>"
   echo "otc elb listmember <lid>"
   echo "otc elb addmember <lid> <vmid> <vmip>"
   echo "otc elb delmember <lid> <mid> <vmip>"
   #elb listcheck <lid> is missing (!)
   echo "otc elb showcheck <cid>"
   echo "otc elb addcheck <lid> <proto> <port> <int> <to> <hthres> <uthres> [<uri>]"
   echo "otc elb delcheck <cid>"
   echo
   echo "--- Relational Database Service (RDS) ---"
   echo "otc rds list"
   echo "otc rds listinstances             # list database instances"
   echo "otc rds show [<id> ...]"
   echo "otc rds showinstances  [<id> ...] # show database instances details"
   echo "otc rds apis"
   echo "otc rds listapis                  # list API ids"
   echo "otc rds showapi <id> ...          # show API detail information"
   echo "otc rds showdatastore <name> ..."
   echo "otc rds datastore <name> ...      # show datastore details (like MySQL)"
   echo "otc rds listflavors"
   echo "otc rds flavors                   # list RDS flavors"
   echo "otc rds showflavor <id> ...       # RDS flavor details"
   echo "otc rds create [<configfile>]     # create RDS instance, read from"
   echo "                                  # stdin when no config file is given"
   echo "otc rds delete <id> <backups>     # remove RDS instances and backups"
   echo
   echo "--- Access Control ---"
   echo "otc iam token           # generate a new iam token"
   echo "otc iam project         # output project_id/tenant_id"
   echo
   echo "--- Global flags ---"
   echo "otc debug CMD1 CMD2 PARAMS      # for debugging REST calls ..."
   echo "otc --insecure CMD1 CMD2 PARAMS # for ignoring SSL security ..."
}

getECSJOBList() {
	if test -z "$1"; then echo
		echo "ERROR: Need to pass job ID to getECSJOBList"
		exit 1
	fi
	#curlgetauth $TOKEN "$AUTH_URL_ECS_JOB/$1"

	ECSCREATEJOBSTATUSJSON=`curlgetauth "$TOKEN" "$AUTH_URL_ECS_JOB/$1"`
	#TODO: JUST FOR DEBUGING TO SEE THE TASK STATUS
	echo $ECSCREATEJOBSTATUSJSON
	ECSCREATEJOBSTATUS=`echo $ECSCREATEJOBSTATUSJSON| jq '.status'|head -n 1 |cut -d':' -f 2 | tr -d '"'| tr -d ' '`

	export ECSCREATEJOBSTATUS
}

getFileContentJSON() {
	INJECTFILE=$1
	if [ "$INJECTFILE" != "" ];then
		IFS='=' read -a FILE_AR <<< "${INJECTFILE}"
		FILENAME_NAME=${FILE_AR[1]}
		TARGET_FILENAME=${FILE_AR[0]}
		FILECONTENT=$( base64 "$FILENAME_NAME" )
		FILE_TEMPLATE='{ "path": "'"$TARGET_FILENAME"'", "contents": "'"$FILECONTENT"'" }'

		export FILEJSONITEM="$FILE_TEMPLATE"
	fi
}

getPersonalizationJSON() {
	if [ "$FILE1" != "" ]; then
		getFileContentJSON $FILE1
		FILECOLLECTIONJSON="$FILEJSONITEM"
	fi
	if [ "$FILE2" != "" ]; then
		getFileContentJSON $FILE2
		FILECOLLECTIONJSON="$FILECOLLECTIONJSON,$FILEJSONITEM"
	fi
	if [ "$FILE3" != "" ]; then
		getFileContentJSON $FILE3
		FILECOLLECTIONJSON="$FILECOLLECTIONJSON,$FILEJSONITEM"
	fi
	if [ "$FILE4" != "" ]; then
		getFileContentJSON $FILE4
		FILECOLLECTIONJSON="$FILECOLLECTIONJSON,$FILEJSONITEM"
	fi
	if [ "$FILE5" != "" ]; then
		getFileContentJSON $FILE5
		FILECOLLECTIONJSON="$FILECOLLECTIONJSON,$FILEJSONITEM"
	fi

	export PERSONALIZATION=""
	if [ "$FILECOLLECTIONJSON" != "" ]; then
		export PERSONALIZATION='"personality": [ '"$FILECOLLECTIONJSON"'],'
	fi
}

ECSCreate() {
	if test -n "$(echo "$INSTANCE_NAME" | sed 's/^[0-9a-zA-Z_\-]*$//')"; then
		echo "ERROR: INSTANCE_NAME may only contain letters, digits, _ and -"
		exit 2
	fi

	getPersonalizationJSON

	if [ -n "$ROOTDISKSIZE" ]; then
		DISKSIZE=', "size": "'$ROOTDISKSIZE'"'
	else
		unset DISKSIZE
	fi
	if test -z "$AZ"; then
		if test -n "$SUBNETAZ"; then
			AZ="$SUBNETAZ"
		else
			echo "ERROR: Need to specify AZ (or derive from subnet)"
			exit 2
		fi
	fi
	if test -n "$SUBNETAZ" -a "$SUBNETAZ" != "$AZ"; then
		echo "ERROR: AZ ($AZ) must match subnets AZ ($SUBNETAZ)"
		exit 2
	fi

	OPTIONAL=""
	if [ "$CREATE_ECS_WITH_PUBLIC_IP" == "true" ]; then
		# TODO: have to got from param
		OPTIONAL="$OPTIONAL
		\"publicip\": {
			\"eip\": {
				\"iptype\": \"5_bgp\",
				\"bandwidth\": {
					\"size\": $BANDWIDTH,
					\"sharetype\": \"PER\",
					\"chargemode\": \"traffic\"
				}
			}
		},"
	fi

	if test -n "$KEYNAME"; then
		OPTIONAL="$OPTIONAL
		\"key_name\": \"$KEYNAME\","
	fi
	if test -n "$ADMINPASS"; then
		OPTIONAL="$OPTIONAL
		\"adminPass\": \"$ADMINPASS\","
	fi
	#OPTIONAL="$OPTIONAL \"__vnckeymap\": \"en\","
	if test -z "$NUMCOUNT"; then NUMCOUNT=1; fi

	SECUGROUPIDS=""
	for id in ${SECUGROUP//,/ }; do
		SECUGROUPIDS="$SECUGROUPIDS { \"id\": \"$id\" },"
	done
	SECUGROUPIDS="${SECUGROUPIDS%,}"

	REQ_CREATE_VM='{
		"server": {
			"availability_zone": "'"$AZ"'",
			"name": "'"$INSTANCE_NAME"'",
			"imageRef": "'"$IMAGE_ID"'",
			"root_volume": {
				"volumetype": "'"$VOLUMETYPE"'"'$DISKSIZE'
			},
			"flavorRef": "'"$INSTANCE_TYPE"'",
			'"$PERSONALIZATION"'
			"vpcid": "'"$VPCID"'",
			"security_groups": [ '"$SECUGROUPIDS"' ],
			"nics": [ { "subnet_id": "'"$SUBNETID"'" } ],
			'"$OPTIONAL"'
			"count": '$NUMCOUNT'
		}
	}'

	echo "$REQ_CREATE_VM"

	if [ "$IMAGE_ID" == "" ]; then
		echo "Image definition not Correct ! Check avaliable images with following command:"
		echo 'otc images list'
		exit 1
	fi
	if [ "$INSTANCE_TYPE" == "" ]; then
		echo "Instance Type definition not Correct ! Please check avaliable flavors  with following command:"
		echo 'otc ecs flavor-list'
		exit 1
	fi
	if [ "$VPCID" == "" ]; then
		echo "VPC definition not Correct ! Please check avaliable VPCs  with following command:"
		echo 'otc vpc list'
		exit 1
	fi
	if [ "$SECUGROUP" == "" ]; then
		echo "Security Group definition not Correct ! Please check avaliable security group with following command:"
		echo 'otc security-group list'
		exit 1
	fi
	if [ "$SUBNETID" == "" ]; then
		echo "Subnet definition not Correct ! Please check avaliable subnets with following command:"
		echo 'otc subnet list'
		exit 1
	fi

	ECSTASKID=`curlpostauth "$TOKEN" "$REQ_CREATE_VM" "$AUTH_URL_ECS_CLOUD" | jq '.job_id' | cut -d':' -f 2 | tr -d '" '`
	# this lines for DEBUG
	export ECSTASKID
}

ECSAction() {
	REQ_ECS_ACTION_VM='
	{
		"'"$ECSACTION"'": {
			"type":"'"$ECSACTIONTYPE"'",
			"servers": [ { "id": "'"$ECSACTIONSERVERID"'" } ]
		}
	}'
	export REQ_ECS_ACTION_VM
	#echo $REQ_ECS_ACTION_VM
	curlpostauth "$TOKEN" "$REQ_ECS_ACTION_VM" "$AUTH_URL_ECS_CLOUD_ACTION"
}

ECSDelete() {
	IDS=""
	for id in "$@"; do
		IDS="$IDS { \"id\": \"$id\" },"
	done
	IDS="${IDS%,}"
	# TODO: Allow options to control this
	# Rationale for defaults: We have allocated the EIP, so clean up.
	REQ_ECS_DELETE='{
		"servers": [ '$IDS' ],
		"delete_publicip": true,
		"delete_volume": false
	}'
	export REQ_ECS_DELETE
	#echo $REQ_ECS_DELETE
	ECSRESP=`curlpostauth "$TOKEN" "$REQ_ECS_DELETE" "$AUTH_URL_ECS_CLOUD_DELETE"`
	ECSTASKID=`echo "$ECSRESP" | jq '.job_id' | cut -d':' -f 2 | tr -d '" '`
	if test -n "$ECSTASKID"; then
		echo "Delete task ID: $ECSTASKID"
	else
		echo "ERROR:"
		echo "$ECSRESP" | jq '.[]'
		return 1
	fi
}

VPCCreate() {
	REQ_CREATE_VPC='{
		"vpc": {
			"name": "'"$VPCNAME"'",
			"cidr": "'"$CIDR"'"
		}
	}'
	export REQ_CREATE_VPC
	#echo $REQ_CREATE_VPC
	curlpostauth "$TOKEN" "$REQ_CREATE_VPC" "$AUTH_URL_VPCS" | jq '.[]'
}

SUBNETCreate() {
	REQ_CREATE_SUBNET='{
		"subnet": {
			"name": "'"$SUBNETNAME"'",
			"cidr": "'"$CIDR"'",
			"gateway_ip": "'"$GWIP"'",
			"dhcp_enable": "true",
			"primary_dns": "'"$PRIMARYDNS"'",
			"secondary_dns": "'"$SECDNS"'",
			"availability_zone":"'"$AZ"'",
			"vpc_id":"'"$VPCID"'"
		}
	}'
	#{ "subnet": { "name": "subnet", "cidr": "192.168.20.0/24", "gateway_ip": "192.168.20.1", "dhcp_enable": "true", "primary_dns": "114.114.114.114", "secondary_dns": "114.114.115.115", "availability_zone":"eu-de-01" ,"vpc_id":"3ec3b33f-ac1c-4630-ad1c-7dba1ed79d85" } }
	export REQ_CREATE_SUBNET
	#echo $REQ_CREATE_SUBNET
	curlpostauth "$TOKEN" "$REQ_CREATE_SUBNET" "$AUTH_URL_SUBNETS" | jq '.[]'
}

PUBLICIPSCreate() {
	if test -z "$BANDWIDTH_NAME"; then BANDWIDTH_NAME="bandwidth-${BANDWIDTH}m-$$"; fi
	REQ_CREATE_PUBLICIPS='{
		"publicip": {
			"type": "5_bgp"
		},
		"bandwidth": {
			"name": "'"$BANDWIDTH_NAME"'",
			"size": '$BANDWIDTH',
			"share_type": "PER"
		}
	}'

	export REQ_CREATE_PUBLICIPS
	echo $REQ_CREATE_PUBLICIPS
	curlpostauth "$TOKEN" "$REQ_CREATE_PUBLICIPS" "$AUTH_URL_PUBLICIPS" | jq '.[]'
}

PUBLICIPSDelete() {
	curldeleteauth "$TOKEN" "$AUTH_URL_PUBLICIPS/$@" | jq '.[]'
}

PUBLICIPSBind() {
	ID=$1
	PORT_ID=$2
	if test -z "$PORT_ID"; then echo "Please define port-id to which the public ip should be bound to."; exit 1; fi
	REQ_BIND_PUBLICIPS='{
		"publicip": {
			"port_id": "'"$PORT_ID"'"
		}
	}'

	export REQ_BIND_PUBLICIPS
	echo $REQ_BIND_PUBLICIPS
	curlputauth "$TOKEN" "$REQ_BIND_PUBLICIPS" "$AUTH_URL_PUBLICIPS/$ID" | jq '.[]'
}

PUBLICIPSUnbind() {
	ID=$1
	REQ_UNBIND_PUBLICIPS='{
		"publicip": {
			"port_id": ""
		}
	}'

	export REQ_UNBIND_PUBLICIPS
	echo $REQ_UNBIND_PUBLICIPS
	curlputauth "$TOKEN" "$REQ_UNBIND_PUBLICIPS" "$AUTH_URL_PUBLICIPS/$ID" | jq '.[]'
}

SECGROUPCreate() {
	REQ_CREATE_SECGROUP='{
		"security_group": {
			"name":"'"$SECUGROUPNAME"'",
			"vpc_id" : "'"$VPCID"'"
		}
	}'
	#{ "security_group": { "name":"qq", "vpc_id" : "3ec3b33f-ac1c-4630-ad1c-7dba1ed79d85" } }
	export REQ_CREATE_SECGROUP
	echo $REQ_CREATE_SECGROUP
	curlpostauth "$TOKEN" "$REQ_CREATE_SECGROUP" "$AUTH_URL_SEC_GROUPS" | jq '.[]'
}

SECGROUPRULECreate() {
	REQ_CREATE_SECGROUPRULE='{
		"security_group_rule": {
			"direction":"'"$DIRECTION"'",
			"port_range_min":"'"$PORTMIN"'",
			"port_range_max":"'"$PORTMAX"'",
			"ethertype":"'"$ETHERTYPE"'",
			"protocol":"'"$PROTOCOL"'",
			"security_group_id":"'"$SECUGROUP"'"
		}
	}'
	#{"security_group_rule":{ "direction":"'"$DIRECTION"'", "port_range_min":"'"$PORTMIN"'", "ethertype":"'"$ETHERTYPE"'", "port_range_max":"'"$PORTMAX"'", "protocol":"'"$PROTOCOL"'", "remote_group_id":"'"$REMOTEGROUPID"'", "security_group_id":"'"$SECUGROUPID"'" } }
	#{"security_group_rule":{ "direction":"ingress", "port_range_min":"80", "ethertype":"IPv4", "port_range_max":"80", "protocol":"tcp", "remote_group_id":"85cc3048-abc3-43cc-89b3-377341426ac5", "security_group_id":"a7734e61-b545-452d-a3cd-0189cbd9747a" } }
	export REQ_CREATE_SECGROUPRULE
	echo $REQ_CREATE_SECGROUPRULE
	curlpostauth "$TOKEN" "$REQ_CREATE_SECGROUPRULE" "$AUTH_URL_SEC_GROUP_RULES" | jq '.[]'
}

WaitForTask() {
   if [ "$WAIT_CREATE" == "true" ];then
	echo "Waiting for Job:   $AUTH_URL_ECS_JOB/$1"
	getECSJOBList $1
	echo -n "#"
	while [ "$ECSCREATEJOBSTATUS" == "RUNNING" ] || [ "$ECSCREATEJOBSTATUS" == "INIT" ]
	do
		sleep $2
		getECSJOBList $1
		echo -n "#"
	done
   else
	getECSJOBList $1
	echo "Note: Not waiting for completion, use otc ecs job $1 to monitor"
   fi
}

# Does not seem to work :-(
DeleteTask() {
	curldeleteauth "$TOKEN" "$AUTH_URL_ECS_JOB/$1"
}

getUserDomainIdFromIamResponse() {
	tail -n1 | jq -r .token.user.domain.id
}

##########################################################################################

# Package dependency #####################################################################

# check libs3 installed
command -v s3 >/dev/null 2>&1 || { echo -n>&2 "Note: otc requires libs3 package to be installed for object storage operations.
Please install libs3 or libs3-2 using yum/apt-get/zypper.
Continuing anyway ..."; }

# check jq installed
command -v jq >/dev/null 2>&1 || { echo -n>&2 "ERROR: otc requires jq package to be installed.
Please install jq using yum/apt-get/zypper.
Aborting."; exit 1; }

##########################################################################################

# Command Line Parser ####################################################################

# Insecure
if test "$1" == "--insecure" -o "$1" == "-k"; then
	INS=$1; shift
else
	if test -n "$OS_CACERT"; then INS="--cacert $OS_CACERT"; else unset INS; fi
fi

# Debugging
if test "$1" = "debug"; then DEBUG=1; shift; fi

# fetch main command
MAINCOM=$1; shift
# fetch subcommand
SUBCOM=$1; shift

#if [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "create" ] || [ "$MAINCOM" == "vpc" ] && [ "$SUBCOM" == "create" ];then
if [ "$SUBCOM" == "create" ]; then
	while [[ $# > 0 ]]
	do
		key="$1"

		case $key in
			-a|--admin-pass)
			ADMINPASS="$2"
			shift # past argument
			;;
			-n|--instance-name)
			INSTANCE_NAME="$2"
			shift # past argument
			;;
			--file1)
			FILE1="$2"
			shift # past argument
			;;
			--file2)
			FILE2="$2"
			shift # past argument
			;;
			--file3)
			FILE3="$2"
			shift # past argument
			;;
			--file4)
			FILE4="$2"
			shift # past argument
			;;
			--file5)
			FILE5="$2"
			shift # past argument
			;;
			-t|--instance-type)
			INSTANCE_TYPE="$2"
			shift # past argument
			;;
			-i|--image-name)
			IMAGENAME="$2"
			shift # past argument
			;;
			--image-id)
			IMAGE_ID="$2"
			shift # past argument
			;;
			-c|--count)
			NUMCOUNT="$2"
			shift # past argument
			;;
			-b|--subnet-id)
			SUBNETID="$2"
			shift # past argument
			;;
			--subnet-name)
			SUBNETNAME="$2"
			shift # past argument
			;;
			-v|--vpc-id)
			VPCID="$2"
			shift # past argument
			;;
			--vpc-name)
			VPCNAME="$2"
			shift # past argument
			;;
			--cidr)
			CIDR="$2"
			shift # past argument
			;;
			--gateway-ip)
			GWIP="$2"
			shift # past argument
			;;
			--primary-dns)
			PRIMARYDNS="$2"
			shift # past argument
			;;
			--secondary-dns)
			SECDNS="$2"
			shift # past argument
			;;
			-z|--availability-zone|--az)
			AZ="$2"
			shift # past argument
			;;
			-s|--security-group-ids)
			SECUGROUP="$2"
			shift # past argument
			;;
			-g|--security-group-name)
			SECUGROUPNAME="$2"
			shift # past argument
			;;
			-p|--public)
			CREATE_ECS_WITH_PUBLIC_IP="$2"
			shift # past argument
			;;
			--disktype|--disk-type)
			VOLUMETYPE="$2"
			shift # past argument
			;;
			--disksize|--disk-size)
			ROOTDISKSIZE="$2"
			shift # past argument
			;;
			--direction)
			DIRECTION="$2"
			shift # past argument
			;;
			--portmin|--port-min)
			PORTMIN="$2"
			shift # past argument
			;;
			--portmax|--port-max)
			PORTMAX="$2"
			shift # past argument
			;;
			--protocol)
			PROTOCOL="$2"
			shift # past argument
			;;
			--ethertype|--ether-type)
			ETHERTYPE="$2"
			shift # past argument
			;;
			--key-name)
			KEYNAME="$2"
			shift # past argument
			;;
			--bandwidth-name)
			BANDWIDTH_NAME=$2
			shift # past argument
			;;
			--bandwidth)
			BANDWIDTH=$2
			shift # past argument
			;;
			--wait)
			WAIT_CREATE="true"
			;;
			--nowait)
			WAIT_CREATE="false"
			;;
			--hard)
			ECSACTIONTYPE="HARD"
			;;
			--soft)
			ECSACTIONTYPE="SOFT"
			;;
			--default)
			DEFAULT=YES
			;;
			-*)
			# unknown option
			echo "ERROR: unknown option \"$1\""
			exit 1
			;;
			*)
			break
			;;
		esac

		shift # past argument or value
	done
fi

##########################################################################################

# MAIN ###################################################################################

#echo "Execute $MAINCOM $SUBCOM"

if [ "$MAINCOM" == "s3" ]; then
   s3 $SUBCOM "$@"
   exit $?
fi

if [ -n "$MAINCOM" -a "$MAINCOM" != "help" ]; then
    getIamToken
fi

if [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "list" ]; then
   getECSList

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "list-detail" ]; then
   getECSDetail

elif [ "$MAINCOM" == "ecs" -a "$SUBCOM" == "show" ] ||
     [ "$MAINCOM" == "ecs" -a "$SUBCOM" == "vm" ]; then
   VM=$1
   getECSVM

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "create" ]; then

   if [ "$VPCNAME" != "" ]; then convertVPCNameToId; fi
   if [ "$SUBNETNAME" != "" ]; then convertSUBNETNameToId; fi
   if [ "$IMAGENAME" != "" ]; then convertIMAGENameToId; fi
   if [ "$SECUGROUPNAME" != "" ] && [ "$SECUGROUP" == "" ]; then convertSECUGROUPNameToId; fi

   ECSCreate "$NUMCOUNT" "$INSTANCE_TYPE" "$IMAGE_ID" "$VPCID" "$SUBNETID" "$SECUGROUP"
   echo "$ECSTASKID"

   WaitForTask $ECSTASKID 10
   echo "ECS Creation status: $ECSCREATEJOBSTATUS"
   if [ "$ECSCREATEJOBSTATUS" != "SUCCESS" ];then
	exit 1
   fi

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "reboot-instances" ];then
   export ECSACTION="reboot"
   export ECSACTIONSERVERID=$1

   if [ "$ECSACTIONSERVERID" == "" ];then
	echo "ERROR: Must be specify the Instance ID!"
	printHelp
	exit 1
   fi

   ECSAction

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "start-instances" ];then
   ECSACTION="os-start"
   ECSACTIONSERVERID=$1
   if [ "$ECSACTIONSERVERID" == "" ];then
	echo "ERROR:: Must be specify the Instance ID!"
	printHelp
	exit 1
   fi

   ECSAction

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "stop-instances" ];then
   ECSACTION="os-stop"
   ECSACTIONSERVERID=$1

   if [ "$ECSACTIONSERVERID" == "" ];then
	echo "ERROR: Must be specify the Instance ID!"
	printHelp
	exit 1
   fi

   ECSAction

elif [ "$MAINCOM" == "ecs" -a "$SUBCOM" == "job" ] ||
     [ "$MAINCOM" == "task" -a "$SUBCOM" == "show" ]; then
   #ECSTASKID=$1
   #echo $AUTH_URL_ECS_JOB/$1
   getECSJOBList $1

elif [ "$MAINCOM" == "task" -a "$SUBCOM" == "delete" ]; then
   DeleteTask $1

elif [ "$MAINCOM" == "ecs" -a "$SUBCOM" == "delete" ]; then
   ECSDelete $@

elif [ "$MAINCOM" == "vpc" ] && [ "$SUBCOM" == "list" ];then
   getVPCList

elif [ "$MAINCOM" == "vpc" ] && [ "$SUBCOM" == "create" ];then
   VPCCreate

elif [ "$MAINCOM" == "publicip" ] && [ "$SUBCOM" == "list" ];then
   getPUBLICIPSList

elif [ "$MAINCOM" == "publicip" ] && [ "$SUBCOM" == "create" ];then
   PUBLICIPSCreate

elif [ "$MAINCOM" == "publicip" ] && [ "$SUBCOM" == "delete" ];then
   PUBLICIPSDelete $@

elif [ "$MAINCOM" == "publicip" ] && [ "$SUBCOM" == "bind" ];then
   PUBLICIPSBind $@

elif [ "$MAINCOM" == "publicip" ] && [ "$SUBCOM" == "unbind" ];then
   PUBLICIPSUnbind $@

elif [ "$MAINCOM" == "subnet" ] && [ "$SUBCOM" == "list" ];then
   getSUBNETList

elif [ "$MAINCOM" == "subnet" ] && [ "$SUBCOM" == "namelist" ];then
   IMAGENAME=$1
    # convertSUBNETNameToId
    # convertSECUGROUPNameToId
    # convertIMAGENameToId

elif [ "$MAINCOM" == "subnet" ] && [ "$SUBCOM" == "create" ];then

   if [ "$VPCNAME" != "" ];then
	convertVPCNameToId
   fi
   SUBNETCreate

elif [ "$MAINCOM" == "security-group" ] && [ "$SUBCOM" == "list" ];then
   VPCNAME=$1
   if [ "$VPCNAME" != "" ];then
	convertVPCNameToId
   fi

   getSECGROUPList

elif [ "$MAINCOM" == "security-group" ] && [ "$SUBCOM" == "create" ];then
   if [ "$VPCNAME" != "" ];then
	convertVPCNameToId
   fi

   SECGROUPCreate

elif [ "$MAINCOM" == "security-group-rules" ] && [ "$SUBCOM" == "list" ];then
   SECUGROUP=$1

   if [ "$SECUGROUP" == "" ];then
	echo "ERROR: Must be specify the Security Group ID!"
	printHelp
	exit 1
   fi
   #AUTH_URL_SEC_GROUP_RULES="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/security-group-rules/$SECUGROUP"
   getSECGROUPRULESList $SECUGROUP

elif [ "$MAINCOM" == "security-group-rules" ] && [ "$SUBCOM" == "create" ];then

   if [ "$VPCNAME" != "" ];then
	convertVPCNameToId
   fi

   if [ "$SECUGROUPNAME" != "" ];then
	convertSECUGROUPNameToId
   fi

   #AUTH_URL_SEC_GROUP_RULES="${BASEURL/iam/vpc}/v1/$OS_PROJECT_ID/security-group-rules"
   SECGROUPRULECreate

elif [ "$MAINCOM" == "images" ] && [ "$SUBCOM" == "list" ];then
   getIMAGEList

elif [ "$MAINCOM" == "images" ] && [ "$SUBCOM" == "show" ];then
   getIMAGEDetail $1

elif [ "$MAINCOM" == "images" ] && [ "$SUBCOM" == "upload" ];then
   curlputauth $TOKEN "{ \"image_url\":\"$2\" }" "$AUTH_URL_IMAGES/$1/file"

elif [ "$MAINCOM" == "ecs" ] && [ "$SUBCOM" == "flavor-list" ];then
   getFLAVORList

elif [ "$MAINCOM" == "keypair" -a "$SUBCOM" == "list" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "keyname-list" ];then
   getKEYPAIRList

elif [ "$MAINCOM" == "keypair" -a "$SUBCOM" == "show" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "keyname-show" ];then
   getKEYPAIR "$@"

elif [ "$MAINCOM" == "keypair" -a "$SUBCOM" == "create" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "keyname-create" ];then
   createKEYPAIR "$@"

elif [ "$MAINCOM" == "keypair" -a "$SUBCOM" == "delete" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "keyname-delete" ];then
   deleteKEYPAIR "$@"


elif [ "$MAINCOM" == "iam" ] && [ "$SUBCOM" == "token" ];then
   echo $TOKEN
elif [ "$MAINCOM" == "iam" ] && [ "$SUBCOM" == "endpoints" ];then
   curlgetauth $TOKEN "${IAM_AUTH_URL%auth*}endpoints" | jq #'.[]'
elif [ "$MAINCOM" == "iam" ] && [ "$SUBCOM" == "services" ];then
   curlgetauth $TOKEN "${IAM_AUTH_URL%auth*}services" | jq #'.[]'
elif [ "$MAINCOM" == "iam" -a "$SUBCOM" == "project" ] ||
     [ "$MAINCOM" == "iam" -a "$SUBCOM" == "tenant" ]; then
   echo $OS_PROJECT_ID

elif [ "$MAINCOM" == "volume" -a "$SUBCOM" == "list" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "volume-list" ] ||
	[ "$MAINCOM" == "evs" -a "$SUBCOM" == "list" ];then
   getEVSList

elif [ "$MAINCOM" == "volume" -a "$SUBCOM" == "show" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "volume-show" ] ||
	[ "$MAINCOM" == "ecs" -a "$SUBCOM" == "describe-volumes" ] ||
	[ "$MAINCOM" == "evs" -a "$SUBCOM" == "show" ];then
   getEVSDetail $1

elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "list" ]; then
   getELBList

elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "show" ]; then
   getELBDetail $1

elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "delete" ]; then
   deleteELB $1
   echo "$ELBJOBID"
   WaitForTask $ELBJOBID 2

elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "create" ]; then
   createELB "$@"
   echo "$ELBJOBID"
   WaitForTask $ELBJOBID 2

elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "listlistener" ]; then
	getListenerList "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "createlistener" ] ||
     [ "$MAINCOM" == "elb" -a "$SUBCOM" == "addlistener" ]; then
	createListener "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "dellistener" ]; then
	deleteListener "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "listmember" ]; then
	getMemberList "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "addmember" ]; then
	createMember "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "delmember" ]; then
	deleteMember "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "showcheck" ]; then
	getCheck "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "addcheck" ]; then
	createCheck "$@"
elif [ "$MAINCOM" == "elb" -a "$SUBCOM" == "delcheck" ]; then
	deleteCheck "$@"

elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "list" ] ||
	  [ "$MAINCOM" == "rds" -a "$SUBCOM" == "listinstances" ]; then
   getRDSInstanceList
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "show" ] ||
	  [ "$MAINCOM" == "rds" -a "$SUBCOM" == "showinstances" ]; then
   getRDSInstanceDetails "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "apis" ] ||
	  [ "$MAINCOM" == "rds" -a "$SUBCOM" == "listapis" ]; then
	getRDSAPIVersionList
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "showapi" ]; then
	getRDSAPIDetails "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "datastore" ] ||
	  [ "$MAINCOM" == "rds" -a "$SUBCOM" == "showdatastore" ]; then
	getRDSDatastoreDetails "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "flavors" ] ||
	  [ "$MAINCOM" == "rds" -a "$SUBCOM" == "listflavors" ]; then
	getRDSFlavorList "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "showflavor" ]; then
	getRDSFlavorDetails "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "create" ]; then
	createRDSInstance "$@"
elif [ "$MAINCOM" == "rds" -a "$SUBCOM" == "delete" ]; then
	deleteRDSInstance "$@"

else
   printHelp
fi
